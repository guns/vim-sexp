*vim-sexp.txt*	Precision Editing for Symbolic Expressions

            o8o
            '"'
oooo    ooooooo ooo. .oo.  .oo.        .oooo.o  .ooooo. oooo    ooooo.ooooo.
 `88.  .8' `888 `888P"Y88bP"Y88b      d88(  "8 d88' `88b `88b..8P'  888' `88b
  `88..8'   888  888   888   888 8888 `"Y88b.  888ooo888   Y888'    888   888
   `888'    888  888   888   888      o.  )88b 888    .o .o8"'88b   888   888
    `8'    o888oo888o o888o o888o     8""888P' `Y8bod8P'o88'   888o 888bod8P'
                                                                    888
                                                                   o888o

==============================================================================
I. INTRODUCTION                                            *sexp-introduction*

Symbolic Expressions are the simplest way to express recursive tree-like
structures with text, and give Lisps their distinctive look and feel. Emacs
users know that what appear to be a preponderance of brackets are really hooks
the editor may use to effortlessly transform the text before them.

Vim, possessing |cursor-motions| and an |operator-pending| mode, is well
suited for editing structured text. This plugin extends these ideas to
S-Expressions as embodied by both classical Lisps like Scheme and new Lisps
like Clojure.

A handful of features found in the popular S-Expression plugin for emacs,
paredit.el, are also provided.

Treesitter Support ~
                                                     *sexp-treesitter-support*
Conditional support for the Treesitter library was added in September 2025.
This change should have no impact on Vim users, but Neovim users should
notice increased performance, and should no longer need to set the
`additional_vim_regex_highlighting` Treesitter configuration option to make
vim-sexp work correctly. Setting this option was once necessary because the
original implementation used Vim's legacy syntax regions to determine sexp
boundaries. Although the workaround was effective, it caused performance
issues for some users, and in any case, running Vim's syntax engine when
Treesitter is active is redundant. Thus, conditionally-enabled Lua modules
have been added to the implementation to obviate the need for Vim's legacy
syntax engine when Treesitter is available.
Note: Treesitter support has been tested by a handful of users, but if you
notice any issues, please open an issue on Github.

Installation ~

Vim-sexp requires no installation beyond downloading the plugin into your
'runtimepath', which can be done manually or with the aid of a plugin manager.
There are many plugin managers available to users of Vim and Neovim, and no
attempt will be made to cover them all here; however, for the benefit of
Neovim users who may not be accustomed to manual installations, a sample
configuration using the (Neovim-only) Lazy plugin manager is provided in
|sexp-lazy-install|.

==============================================================================
II. MAPPINGS                                                   *sexp-mappings*

This is the list of mappings provided by vim-sexp grouped by type. The default
key mapping is shown on the left and the full <Plug> name on the right.

Note that all actions that result in visual selections will always be
|characterwise|, regardless of the current visual state.

If vim-repeat [1] is installed, repeating the last change with the |.| command
will work as expected, even for changes made with |operator-pending| commands.

The key mappings are only available in |FileType|s that match the
|g:sexp_filetypes| option, but the <Plug> mappings are available globally, so
you can bind them manually in any filetype: e.g.,
>
        " Clojure:
        "   Use the FireplacePrint operator from fireplace.vim [2] to evaluate
        "   the current top-level compound form, compound form, or element
        "   without moving the cursor.
        nmap <Leader>F <Plug>FireplacePrint<Plug>(sexp_outer_top_list)``
        nmap <Leader>f <Plug>FireplacePrint<Plug>(sexp_outer_list)``
        nmap <Leader>e <Plug>FireplacePrint<Plug>(sexp_inner_element)``

        " Screen.vim [3]:
        "   Select the current top-level compound form, compound form, or
        "   element and send it to a GNU Screen window or Tmux pane.
        nmap <Leader>F v<Plug>(sexp_outer_top_list):ScreenSend<CR>``
        nmap <Leader>f v<Plug>(sexp_outer_list):ScreenSend<CR>``
        nmap <Leader>e v<Plug>(sexp_inner_element):ScreenSend<CR>``
<
Insert mode mappings are enabled by default and can be disabled with
|g:sexp_enable_insert_mode_mappings|.

All mappings can be easily changed via |g:sexp_mappings|. Users who prefer
more explicit, opt-in configuration should read |sexp-explicit-mappings|.

Use of Meta/Alt keys in default keymap  ~
Some users may consider a keymap based on Meta/Alt keys more efficient than
one relying primarily on multi-stroke, leader-based sequences. Unfortunately,
Meta key bindings are more likely to cause problems and/or require special
configuration in terminal-based legacy Vim, and for this reason, are used in
only a few of the default bindings. However, users who prefer Meta/Alt keys
should have no difficulty customizing the keymap to use them. Neovim users can
simply map `<A-...>`, but terminal Vim users may need to use the special
termcap `:set` command to ensure Meta/Alt keys are interpreted correctly:
e.g., to allow <M-j> to be used in terminal Vim, put this in your vimrc.
<
set <M-j>=j

Note: The character preceding the `j` is a literal ESC.
:help set-termcap
<

[1]: https://github.com/tpope/vim-repeat
[2]: https://github.com/tpope/vim-fireplace
[3]: https://github.com/ervandew/screen

TEXT OBJECT SELECTIONS (visual, operator-pending) ~

af                                                   *<Plug>(sexp_outer_list)*
if                                                   *<Plug>(sexp_inner_list)*
        Select [count] lists (compound FORMS) delimited by any of '(' and ')',
        '[' and ']', or '{' and '}'. Outer motion includes the delimiting
        brackets and the inner motion excludes them.

        Does not include surrounding whitespace.

        If the cursor is not in a compound form, the current element is
        selected instead. See |<Plug>(sexp_outer_element)|.

aF                                               *<Plug>(sexp_outer_top_list)*
iF                                               *<Plug>(sexp_inner_top_list)*
        Select the current top-level list (compound FORM) delimited by any of
        '(' and ')', '[' and ']', or '{' or '}'. Outer motion includes the
        delimiting brackets and the inner motion excludes them.

        Does not include surrounding whitespace.

        If |g:sexp_maxlines| is -1 (the default), the top-level list is
        determined to be the first parent list with a opening bracket
        on the first column. This is typically much faster than calling
        |searchpairpos()| recursively.

        If the cursor is not in a compound form, the current element is
        selected instead. See |<Plug>(sexp_outer_element)|.

as                                                 *<Plug>(sexp_outer_string)*
is                                                 *<Plug>(sexp_inner_string)*
        Select the current string or regular expression. Outer motion includes
        surrounding quotes, inner motion excludes them.

        Does not include surrounding whitespace.

        The default mappings shadow the internal |as| and |is| mappings. These
        sentence object selections are of limited use in code buffers, but if
        you disagree, see |g:sexp_mappings| for documentation on changing the
        default mappings.

ae                                                *<Plug>(sexp_outer_element)*
ie                                                *<Plug>(sexp_inner_element)*
        In operator pending mode, selects the current element and [count]-1
        additional elements. In visual mode, selects the contiguous range of
        elements either fully or partially included in the current visual
        selection and incorporates [count]-1 additional elements on the cursor
        side of the selection. Without a count, repeated applications of ae in
        visual mode pull additional elements into the selection.

        If the cursor is on whitespace that is not in a string or between line
        comments, the motion targets the subsequent element, if it exists.
        
        An element is defined as:

            * Current string if cursor is in a string
            * Current comment if cursor is in a comment, or in the whitespace
              between two line comments
            * Current compound form if cursor is on a paired bracket
            * Current sequence of leading macro characters and following
              element if cursor is on a macro character
            * Current atom otherwise

        An element always includes leading macro characters.

Outer Element whitespace selection logic ~
                                           *sexp-surrounding-whitespace-rules*
        Inner motion does not include surrounding whitespace, but the outer
        motion attempts to include all the whitespace you would wish to delete
        if you were using the text object to delete element(s).

        Algorithm Description:  ~
        Select as much surrounding whitespace as possible without violating
        the following constraints, some of which are user configurable.
        Note: The constraints are applied to the hypothetical buffer state
        that would be produced by deleting the outer element selection.

            * increase the length of the line containing the start of the
              selection beyond a configurable limit.
              See |g:sexp_cleanup_join_textwidth| to configure limit.
              See |g:sexp_cleanup_join_affinity| to enable join selectively.
            * select whitespace on lines above the first element of the
              selection (unless |g:sexp_cleanup_join_backwards| is set).
            * pull a comment onto the end of an earlier line (unless
              |g:sexp_cleanup_join_comments| is set).
              Rationale: Comments are often element-specific.
            * pull the element following the selection into an end of line
              comment
            * remove all whitespace separating adjacent siblings
            * leave trailing blank lines unless
              |g:sexp_cleanup_keep_empty_lines| is set to a value >= 1,
              representing the maximum number of blanks you'd like to keep.

        The rules may sound complex, but the results mostly obey Ruby's
        "Principle of Least Surprise" and Perl's "Do What I Mean"...

                                                   *sexp-cleanup-vs-extension*
        These text objects can be used to "clean up" the current selection
        and/or pull additional elements into it. Cleaning up might mean
        toggling an "inner" selection to an "outer" one (or vice versa). Or
        perhaps you've selected elements manually using 'v' followed by
        movement commands, and now you wish to select some surrounding
        whitespace in preparation for a delete or change operation. In such
        cases, [count] includes the current selection, treating all partially
        or fully-selected elements as a single "element" in the resulting
        selection: thus, a default [count] of 1 performs cleanup only, and a
        count of 2 would pull in 1 additional element.

        Examples: (spaces in key sequences shown for readability only) ~
>
        Delete 2 outer elements at cursor
          d2ae
        Select current and 2 adjacent outer elements (3 elements in all)
          v3ae
        Select current and 2 *preceding* inner elements
          vie o 3ie
          Note: By moving the cursor to the start of the selection, `o'
          changes the direction of the expansion.
<

aC                                             *<Plug>(sexp_outer_child_tail)*
ac                                             *<Plug>(sexp_outer_child_head)*
iC                                             *<Plug>(sexp_inner_child_tail)*
ic                                             *<Plug>(sexp_inner_child_head)*
        Select the [count]th "child" element from the head (lowercase c) or
        tail (uppercase C) of the current compound form. If cursor is not on
        the macro chars or paired bracket of a compound form, the containing
        form is used. If there is no containing form (cursor at toplevel), it
        is as though a virtual form encloses the file itself (i.e., [count]th
        toplevel element from beginning or end of file).

        The meaning of the terms "inner" and "outer" are as defined for the ie
        and ae text objects. 

                                             *sexp-child-objects-vs-[e-and-]e*
        There is overlap between the use cases for child objects and the
        select prev/next element commands ([e and ]e). The chief difference is
        that a child object's offset is always specified relative to the start
        or end of a compound form, whereas [e and ]e always search relative to
        the cursor position. Depending on the use case, one set of commands
        may be significantly more convenient than the other.

TEXT OBJECT MOTIONS (normal, visual, operator-pending) ~

(                                          *<Plug>(sexp_move_to_prev_bracket)*
)                                          *<Plug>(sexp_move_to_next_bracket)*
        [count] paired brackets backward or forward, |exclusive|.

        When used in |operator-pending| mode, the following exceptions apply:

            * [count] is ignored
            * Backward motion excludes the foremost bracket
            * Forward motion from a bracket excludes both the current bracket
              and the last bracket, unless the resulting selection is empty,
              in which case the motion includes both brackets

        The default mappings shadow the internal |(| and |)| mappings. These
        sentence object motions are of limited use in code buffers, but if
        you disagree, see |g:sexp_mappings| for documentation on changing the
        default mappings.

<M-b>                                 *<Plug>(sexp_move_to_prev_element_head)*
<M-w>                                 *<Plug>(sexp_move_to_next_element_head)*
        [count] sibling elements backward or forward, |exclusive|, placing the
        cursor on the head of an element. Movement is bounded by the parent
        list, if any.

        Analogous to |b| and |w| motions.

g<M-e>                                *<Plug>(sexp_move_to_prev_element_tail)*
<M-e>                                 *<Plug>(sexp_move_to_next_element_tail)*
        [count] sibling elements backward or forward, |inclusive|, placing the
        cursor on the tail of an element. Movement is bounded by the parent
        list, if any.

        Analogous to |ge| and |e| motions.

[[                                     *<Plug>(sexp_move_to_prev_top_element)*
]]                                     *<Plug>(sexp_move_to_next_top_element)*
        [count] top-level elements backward or forward, |exclusive|.

        If |g:sexp_maxlines| is -1 (the default) and the current element is
        in a list, the top-level element is determined to be the first parent
        list with a opening bracket on the first column. This is typically
        much faster than calling |searchpairpos()| recursively.

[e                                          *<Plug>(sexp_select_prev_element)*
]e                                          *<Plug>(sexp_select_next_element)*
        Select [count]th element from the current element. Unlike the others,
        these motions always result in a visual selection of a single element,
        even when called from visual mode (typically the current selection is
        extended).

        This motion is particularly useful in |operator-pending| mode. For
        instance, in an (if pred then else) form with the cursor on "pred",
        c]e will delete and insert at the "then" form, while c2]e will delete
        and insert at the "else" form.

"FLOW" COMMANDS (normal, visual) ~

Although the preceding commands are useful for moving forward and backward
within a list, sometimes you want to "escape" from the current list, or
descend into a child list. The commands in this section are called "flow"
commands because they permit you to flow freely in and out of lists. In fact,
it is possible to use an unbroken sequence of flow commands to move all the
way from one end of the buffer to the other. Flow commands fall into 2 basic
categories:

1. List
   Land only on brackets. There are 4 variants, differentiated by both the
   direction moved in the buffer, and the type of bracket landed on (open or
   close).
   
2. Leaf
   Land only on leaf (non-list) elements (atoms, strings, comments)

Visualizing forms as trees ~
It may be helpful to visualize a top-level form as a "tree" whose nodes can be
either branches (lists) or leaves (atoms, strings, comments). One pair of list
flow commands traverses the trees in depth-first fashion, skipping over leaf
elements. A second pair of list flow commands permits "rewinding" these
traversals (e.g., when a command from the first pair has gone too far). Leaf
flow commands also perform a sort of depth-first traversal, but unlike list
flow commands, jump directly from leaf to leaf, never stopping on a bracket.

Note: The list and leaf commands are complementary and completely orthogonal:
the target of a list flow command can never be the target of a leaf flow
command, and vice-versa; moreover, every element in the buffer can be reached
using either list or leaf flow commands, but not both.

Visual and operator-pending mode note ~
Because the flow commands are designed to cross list boundaries,
operator-pending commands and commands that extend the visual selection would
make it too easy for the user to destroy bracket balance. For this reason, the
flow commands are not defined in operator-pending mode at all, and the visual
mode variants do not extend the current selection, but simply select the
target element/list. Note that this is actually a very useful feature, which
allows you to use the flow commands much as you would use |]e| and |[e|, but
without being confined to the current list.

Idiom: Use v[count]<M-S-w> in normal mode to select the [count]th non-list
element from cursor. (Once you get the hang of ignoring brackets, it's easy to
select an arbitrary child, grandchild or even more deeply-nested element with
a single command.)

List flow commands ~

<M-]>                                         *<Plug>(sexp_flow_to_next_open)*
        [count] open brackets forward (ignoring any close brackets). Movement
        is NOT bounded by the parent list.
        Performs left-to-right, depth-first traversal of each form
        encountered.

<M-{>                                         *<Plug>(sexp_flow_to_prev_open)*
        [count] open brackets backward (ignoring any close brackets). Movement
        is NOT bounded by the parent list.
        Visits the same positions as the preceding command, but in reverse
        order: i.e, may be used to "rewind" a sequence of <M-]> commands.
        Note: If your terminal doesn't recognize <M-{>, try <M-S-[> instead.

<M-[>                                        *<Plug>(sexp_flow_to_prev_close)*
        [count] close brackets backward (ignoring any open brackets). Movement
        is NOT bounded by the parent list.
        Performs right-to-left, depth-first traversal of each form
        encountered.

<M-}>                                        *<Plug>(sexp_flow_to_next_close)*
        [count] close brackets forward (ignoring any open brackets). Movement
        is NOT bounded by the parent list.
        Visits the same positions as the preceding command, but in reverse
        order: i.e, may be used to "rewind" a sequence of <M-[> commands.
        Note: If your terminal doesn't recognize <M-}>, try <M-S-]> instead.

Note: Another way of looking at the list flow commands is that the
square-bracket commands tend to move down into lists, whereas the
curly-bracket commands tend to move up and out of them. While it's true that
the square-bracket commands also move out of lists, they do so only when they
can go no deeper. In this way, they are exactly like depth-first tree
traversals, which always choose to descend when descent is possible.

List flow command examples: ~
        Note: | denotes starting cursor position.
              ^ denotes positions reached by successive applications of the
                indicated command.

        sexp_flow_to_next_open               forward / in ~
                                   | (x1 (x2) (x3 (x4) (x5))) (x6)
                                     ^   ^    ^   ^    ^      ^
                                     1   2    3   4    5      6
                                   --------------------------->

        sexp_flow_to_prev_open               backward / out ~
                                     (x1 (x2) (x3 (x4) (x5))) (x6) |
                                     ^   ^    ^   ^    ^      ^
                                     6   5    4   3    2      1
                                     <------------------------------

        sexp_flow_to_prev_close              backward / in ~
                                     (x1) (((x2) (x3) x4) (x5) x6) |
                                        ^      ^    ^   ^    ^   ^
                                        6      5    4   3    2   1
                                     <------------------------------

        sexp_flow_to_next_close              forward / out ~
                                   | (x1) (((x2) (x3) x4) (x5) x6)
                                        ^      ^    ^   ^    ^   ^
                                        1      2    3   4    5   6
                                   ------------------------------>


Leaf flow commands ~

<M-S-b>                                  *<Plug>(sexp_flow_to_prev_leaf_head)*
<M-S-w>                                  *<Plug>(sexp_flow_to_next_leaf_head)*
        [count] leaf (non-list) elements backward or forward, placing the
        cursor on the head of an element. Movement is NOT bounded by the
        parent list.

        Analogous to |b| and |w| motions.

<M-S-g>                                  *<Plug>(sexp_flow_to_prev_leaf_tail)*
<M-S-e>                                  *<Plug>(sexp_flow_to_next_leaf_tail)*
        [count] leaf (non-list) elements backward or forward, placing the
        cursor on the tail of an element. Movement is NOT bounded by the
        parent list.

        Analogous to |ge| and |e| motions.


CLONE COMMANDS (normal, visual) ~

<LocalLeader>c                                       *<Plug>(sexp_clone_list)*
<LocalLeader>C                                    *<Plug>(sexp_clone_element)*
                                                  *<Plug>(sexp_clone_list_sl)*
                                               *<Plug>(sexp_clone_element_sl)*
                                                  *<Plug>(sexp_clone_list_ml)*
                                               *<Plug>(sexp_clone_element_ml)*
        Insert [count] copies of the current list (compound FORM), element or
        visual selection (hereafter referred to as "target"), preserving
        cursor position relative to original.

        In visual mode, the selection is first expanded to cover all partially
        selected lists and elements so that structural integrity is
        maintained.

                                                            *sexp-clone-logic*
        A "multi-line" clone is one in which the copies of the target are
        separated from the target (and from each other) by a newline. The
        default logic selects multi-line operation whenever any of the
        following conditions are met:

                * target spans multiple lines
                * target is on a line by itself, possibly followed by a
                  trailing comment
                * target is the first or last element of a list whose open and
                  close brackets are not colinear, and none of the target's
                  sibling elements (ignoring any trailing comment) are
                  colinear with target
                * target is at toplevel
                * final (or only) element of target is an end-of-line comment
        Note: If the target in a multi-line clone is followed immediately by
        an end-of-line comment, the comment will be cloned along with the
        target (whether explicitly selected or not).

        Overriding the default clone logic ~
        Command variants forcing single-line (`_sl`) or multi-line (`_ml`)
        clones are provided, but not mapped by default. If you find yourself
        frequently wishing to override the default behavior, simply add the
        following to your `g:sexp_mappings` list (with `...` replaced by the
        desired lhs):
>
        \ 'sexp_clone_list_sl': '...',
        \ 'sexp_clone_element_sl': '...',
        \ 'sexp_clone_list_ml': '...',
        \ 'sexp_clone_element_ml': '...',
<

        By default, the clone command triggers automatic re-indent of the
        affected forms whenever the cloned elements span multiple lines. If
        you dislike this behavior, see |sexp-auto-indent|.


INDENT COMMANDS (normal, visual) ~

==                                                       *<Plug>(sexp_indent)*
=-                                                   *<Plug>(sexp_indent_top)*
        In normal mode, indent [count] surrounding lists (compound FORMs) or
        visual selection (==) or current top-level list (=-) without moving
        the cursor. If the cursor is not in a compound FORM, the current
        element is indented instead.

        In visual mode, the selection is first expanded to cover all partially
        selected lists and elements.
        Note: Visual mappings are not created for the "top" variants of indent
        commands; such commands would be pointless because "top" implies
        ignoring the visual selection.

        `==` shadows the builtin |==| mapping. If you wish to remap this
        command, see |g:sexp_mappings| for more information.
        Note: The presence of builtin = would result in an undesirable delay
        if == were used for sexp_indent in visual mode; accordingly, if you
        have not overridden the default mapping for sexp_indent, = is used
        instead of == for visual mode sexp_indent.

Indent with whitespace cleanup ~
                                                           *sexp-clean-indent*

<M-=>                                          *<Plug>(sexp_indent_and_clean)*
<M-->                                      *<Plug>(sexp_indent_and_clean_top)*
        Like == (|sexp_indent)| and =- (|sexp_indent_top|), but also removes
        extra whitespace.

        The rules for determining whether whitespace is "extra" obey the
        "principle of least surprise" mentioned under
        |surrounding-whitespace-rules|.

        If |g:sexp_indent_does_clean| is set (unset by default), the regular
        (non-cleaning) indent commands (`==` and `=-`) also perform whitespace
        "cleanup".

        *Tip:* Users who expect to use only one of the two forms of indent
        (cleaning or non-cleaning) can unbind <M-=> and <M--> and use
        |g:sexp_indent_does_clean| to ensure that == and =- give the desired
        behavior.


COMMENT ALIGNMENT COMMANDS (normal, visual)  ~
                                                      *sexp-comment-alignment*

<LocalLeader>a                                   *<Plug>(sexp_align_comments)*
<LocalLeader>A                               *<Plug>(sexp_align_comments_top)*
        In normal mode, align trailing comments within [count] surrounding
        lists (compound FORMs) or visual selection (`<LocalLeader>a`) or
        current top-level list (`<LocalLeader>A`) without moving the cursor.
        *Note:* Trailing comment alignment makes the most sense on ranges
        spanning more than a few lines; thus, the |sexp_align_comments_top|
        (`<LocalLeader>A`) command is probably the most useful.
        
        In visual mode, the selection is first expanded to cover all partially
        selected lists and elements.
        Note: Visual mappings are not created for the "top" variants of align
        commands, since "top" implies ignoring the visual selection.

                                            *sexp-comment-alignment-algorithm*
        Comment Alignment Algorithm ~
        The default alignment mode uses a weighted-cost "Dynamic Programming"
        algorithm to partition the trailing comments into alignment groups,
        with the goal of keeping the comments sufficiently close to the code
        they describe to prevent disorientation, but not so close as to
        necessitate many small groups, thereby defeating the purpose of
        alignment. Obviously, there are tradeoffs involved here, and the
        optimal balance is a matter of user preference. Accordingly, a set of
        options are provided to allow the user to tailor the algorithm to
        taste. Some of these options establish limits and thresholds: e.g.,
        the maximum number of screen columns a comment can be shifted from the
        code it describes. Others set the relative importance (weighting) of
        various criteria used to compare the "cost" of each candidate grouping
        against competing candidates. These options are described in detail in
        the options section; however, an overview of the cost criteria
        considered by the algorithm is provided below...

                                        *sexp-comment-alignment-cost-criteria*
        Comment Alignment Cost Criteria ~
        In no particular order, these are the comment grouping criteria that
        the dynamic programming algorithm attempts to balance.
                shift      the number of screen columns comments must be
                           shifted rightward to align all comments in a group.
                           Since the shift may not be the same for all
                           comments in a group, the algorithm considers the
                           integral of the shifts.
                numgroups  total number of comment groups required by the
                           alignment. As a general rule, fewer groups is
                           better, but of course, fewer groups tend to result
                           in larger average shift.
                runtness   For groups whose span meets or exceeds a minimum
                           threshold (|g:sexp_aligncom_runt_thresh|), this
                           figure of merit has no impact on alignment, but it
                           deprioritizes smaller groups with a cost penalty
                           that grows non-linearly as the length of the span
                           decreases. The purpose of this figure of merit is
                           to discourage very small ("runt") groups.
                density    comments per line (ignoring lines between groups).
                           Used primarily to minimize groups with "bookend"
                           comments and/or long sequences of lines without
                           trailing comments within a group.
                textwidth  how well the aligned comments stay within the
                           configured textwidth (|g:sexp_aligncom_textwidth|).
                           Candidate groups that force trailing comments to
                           exceed this limit are assessed a cost penalty
                           proportional to the overrun.

        Note: The criteria costs are generally cumulative costs. To understand
        why this is so, consider that each candidate group implies a
        particular layout, and it is the layouts, not the individual comment
        groupings, which are being compared.

                                     *sexp-comment-alignment-criteria-weights*
        Comment Alignment Criteria Weights ~
        By default, all criteria have the same relative importance, but each
        has a dedicated option variable with a name given by
        `g:sexp_aligncom_{<criteria>}_weight`, which can be set to any value
        in the range 0..10 to adjust its relative weight. For instance, a user
        with a strong preference for long blocks of comments, who doesn't mind
        comments being shifted a significant distance from the code they
        describe, might reduce the 'shift' weight and increase
        |g:sexp_aligncom_maxshift| to permit the shift needed for greater
        group consolidation.
        Note: If you're concerned that increasing 'maxshift' might allow
        comments to shift too far, keep in mind that the 'textwidth' criterion
        can reduce this risk, as long as |g:sexp_aligncom_textwidth| is set to
        an appropriate value. Similarly, a user who doesn't care about keeping
        the total number of comment blocks low, as long as none of the blocks
        are too small, could reduce the 'numgroups' weight, and possibly
        increase |g:sexp_aligncom_runt_thresh. Feel free to experiment with
        the weights on a sample block of code until you find a combination
        that produces results you like.

                                  *sexp-comment-alignment-optimization-levels*
        Comment Alignment Optimization Levels ~
        The aforementioned dynamic programming algorithm is reasonably fast,
        and unlikely to cause performance issues in common usage scenarios.
        However, because it's difficult to predict the size blocks users will
        attempt to format, vim-sexp provides several simpler (and consequently
        faster) algorithms. The optimization levels currently supported are as
        follows (fastest to slowest):
        0    Greedy
                 Make each group as large as possible without violating one of
                 the user-specified limits: e.g., |g:sexp_aligncom_maxshift|.
                 *Disadvantage:* May produce layouts with long groups followed
                 by very short ones.
        1    Greedy with lookback
                 Similar to "Greedy", but when a short group
                 (< |g:sexp_aligncom_greedy_lookback|) follows a long group, a
                 localized full optimization is performed on the boundary
                 region in an attempt to "rebalance" the groups.
        2    Full dynamic programming optimization (the default and best)

        *Recommendation:* If you're happy with the performance, always use level
        2 (full optimization). If you sometimes align very large comment
        ranges and notice performance issues, you can reduce
        |g:sexp_aligncom_optlevel| to 0 or 1. Note, however, that indent and
        whitespace cleanup are far more likely culprits where performance
        issues are concerned. Thus, you should definitely do some benchmarking
        before reducing the default optimization level.

                                                         *sexp-align-on-indent*
        Just as it's possible to configure the indent commands to trigger an
        automatic whitespace cleanup, it's also possible to configure them
        to perform an automatic trailing comment alignment:
>
        let g:sexp_indent_aligns_comments = 1
<
        Keep in mind, however, that automatic comment alignment operates on
        the same range as the auto-indent, and because it works by grouping
        comments into alignment blocks, it works best when it operates on many
        lines (e.g., a top-level form). Thus, you may wish to leave this
        option disabled and use `\A` (|sexp_align_comments_top|) at regular
        intervals to keep comments aligned.

WRAP COMMANDS (normal, visual) ~

<LocalLeader>i                             *<Plug>(sexp_round_head_wrap_list)*
<LocalLeader>I                             *<Plug>(sexp_round_tail_wrap_list)*
<LocalLeader>[                            *<Plug>(sexp_square_head_wrap_list)*
<LocalLeader>]                            *<Plug>(sexp_square_tail_wrap_list)*
<LocalLeader>{                             *<Plug>(sexp_curly_head_wrap_list)*
<LocalLeader>}                             *<Plug>(sexp_curly_tail_wrap_list)*
        Wrap the current list (compound FORM) or visual selection with '(' and
        ')', '[' and ']', or '{' and '}' and place the cursor at the head or
        tail of the newly created list.

        If |g:sexp_insert_after_wrap| is set (true by default), insert mode is
        entered. Additionally, if the cursor is to be set at the head of the
        list, a space is conditionally appended after the opening bracket so
        that any typed characters will be separated from the next element.

<LocalLeader>W                          *<Plug>(sexp_round_head_wrap_element)*
<LocalLeader>w                          *<Plug>(sexp_round_tail_wrap_element)*
<LocalLeader>e[                        *<Plug>(sexp_square_head_wrap_element)*
<LocalLeader>e]                        *<Plug>(sexp_square_tail_wrap_element)*
<LocalLeader>e{                         *<Plug>(sexp_curly_head_wrap_element)*
<LocalLeader>e}                         *<Plug>(sexp_curly_tail_wrap_element)*
        Wrap the current element or visual selection with '(' and ')', '[' and
        ']', or '{' and '}' and place the cursor at the head or tail of the
        newly created list.

        If |g:sexp_insert_after_wrap| is set (true by default), insert mode is
        entered. Additionally, if the cursor is to be set at the head of the
        list, a space is conditionally appended after the opening bracket so
        that any typed characters will be separated from the next element.

CURSOR INSERTION (normal) ~

<LocalLeader>h                              *<Plug>(sexp_insert_at_list_head)*
<LocalLeader>l                              *<Plug>(sexp_insert_at_list_tail)*
        Move cursor to head or tail of current list (compound FORM) and enter
        insert mode.

        If inserting at the head, a space is conditionally appended after the
        opening bracket so that any typed characters will be separated from
        the next element.

LIST MANIPULATION (normal, visual) ~

<LocalLeader>@                                      *<Plug>(sexp_splice_list)*
        Splice the current list (compound FORM) into its parent scope [count]
        times by deleting each list's brackets. This mapping is not available
        in visual mode.

        By default, the splice command triggers automatic re-indent whenever
        the splice target is multi-line. If you dislike this behavior, see
        |sexp-auto-indent|.


<LocalLeader>o                                       *<Plug>(sexp_raise_list)*
<LocalLeader>O                                    *<Plug>(sexp_raise_element)*
        Replace [count] enclosing lists (compound FORMs) with the current
        list, element, or visual selection.

        By default, the raise command triggers automatic re-indent whenever
        the raise target is multi-line. If you dislike this behavior, see
        |sexp-auto-indent|.


<LocalLeader>?                                        *<Plug>(sexp_convolute)*
        Splice the tail of the current list into the current list's parent,
        moving the head of the current list to the head of a new list
        containing the [count]th parent of the current list.

        Definitions ~
        current list:  list containing cursor
        list head:     elements in current list lying completely before cursor
        list tail:     elements in current list lying on or after cursor

        Note: This mapping is not available in visual mode. (Since convolution
        is defined in terms of cursor position, a visual mode variant would
        introduce significant ambiguity without providing any appreciable
        benefit: hence, convolute is supported only in normal mode.)

        Comparison with Emacs Paredit ~
        This convolute is very similar to the Emacs Paredit version, but in
        some cases a bit smarter. For instance, Paredit always divides the
        current list _at_ the cursor, even if this means doing something silly
        (and potentially dangerous) like splitting an atom. Vim-sexp on the
        other hand always attempts to divide the current list at a sensible
        location: preferably at the head of the current element (or the
        subsequent one if cursor is in whitespace between elements).

        Intended Use Case ~
        Widen the scope of a let binding to include [count] ancestor forms.
        The following examples illustrate the intended usage.
        Note: cursor position denoted by `|'

        Original Form: ~
        (defun foo (a b)
          (if (bar x y)
              (baz (let ((x 1) (y 2))
                     |(+ x y)))))

        Example 1: convolute with [count]=1 (default): ~
        (defun foo (a b)
          (if (bar x y)
              (let ((x 1) (y 2))
                (baz |(+ x y)))))

        Example 2: convolute with [count]=2: ~
        (defun foo (a b)
          (let ((x 1) (y 2))
            (if (bar x y)
                (baz |(+ x y)))))

<M-k>                                        *<Plug>(sexp_swap_list_backward)*
<M-j>                                         *<Plug>(sexp_swap_list_forward)*
<M-h>                                     *<Plug>(sexp_swap_element_backward)*
<M-l>                                      *<Plug>(sexp_swap_element_forward)*
        Swap the current list (compound FORM), element, or visual selection
        [count] times with the adjacent list or element. Does nothing if there
        is no adjacent element in the desired direction.

        If moving a visual selection, the selection is first expanded to cover
        all partially selected lists and elements so that structural integrity
        is maintained.

        If moving an even number of elements with a visual selection, the
        swap is done pairwise to preserve the associative structure of the
        containing compound form.

<M-S-j>                                       *<Plug>(sexp_emit_head_element)*
<M-S-k>                                       *<Plug>(sexp_emit_tail_element)*
<M-S-h>                                    *<Plug>(sexp_capture_prev_element)*
<M-S-l>                                    *<Plug>(sexp_capture_next_element)*
        Emit  ~
        Emit [count] terminal non-comment elements (along with surrounding
        comments) from the current list (or nearest ancestor with elements to
        emit).

        Capture  ~
        Capture [count] non-comment elements from parent list (or nearest
        ancestor with elements to capture), skipping over comments as
        necessary to find the next capturable element.

        In the absence of a [count], each emit/capture operation moves a
        single element one level up or down, respectively. As long as there
        are elements to capture/emit at higher levels of the sexp tree, the
        operation will not block.

                                                      *sexp-emit-cursor-logic*
        Cursor Positioning (Emit)  ~
        To prevent loss of editing context, vim-sexp attempts to keep the
        cursor position unchanged relative to the current element, even when
        that element is emitted from its containing list. When the cursor
        "escapes" a list in this way, a subsequent emit will operate on the
        parent list. Although this behavior seems quite natural when
        successive emit operations are triggered manually, it could be
        surprising when a [count] is used. Thus, a future version of vim-sexp
        may prevent cursor emission for an emit with a [count] (or may provide
        an option governing this behavior). To ensure the cursor is never
        emitted from its list, simply set |g:sexp_emitting_bracket_is_sticky|
        to have the cursor stick to the emitting list bracket when the bracket
        passes over it.

                                                   *sexp-capture-cursor-logic*
        Cursor Positioning (Capture)  ~
        The default capture logic also attempts to preserve cursor position
        relative to the current element, but what if the cursor is positioned
        not on an element, but on the capturing bracket itself? By default, it
        stays put in this case, since that's how Paredit works; however, if
        you would prefer that the cursor move with the capturing bracket in
        this scenario, simply set |g:sexp_capturing_bracket_is_sticky|.

        Heuristic: If the cursor touches a "sticky" capturing/emitting bracket
        (either because the bracket is passing over it (emit) or because the
        cursor started out on the bracket (capture)), it will move with the
        bracket.
        
        Visual Selection  ~
        In visual mode, the list doing the capturing or emitting will be
        selected after the operation. Note that selecting the list effectively
        prevents "cursor escape", thereby ensuring that successive emits in
        visual mode operate on the same list, regardless of "sticky" options.

        These commands are similar to "barfage" and "slurpage" in paredit.el.

        By default, captures/emits affecting multiple lines trigger an
        automatic re-indent. If you dislike this behavior, see
        |sexp-auto-indent|.

        Capture Examples:  ~
>
        (((|foo) bar) baz)
        (((|foo bar)) baz)
        (((|foo bar) baz))
        (((|foo bar baz)))
<
        Emit Examples:  ~

        -- g:sexp_emitting_bracket_is_sticky == 0 --  ~
>
        (((foo |bar)))
        (((foo) |bar))
        (((foo)) |bar)
<
        -- g:sexp_emitting_bracket_is_sticky == 1 --  ~
>
        (((foo |bar)))
        (((foo|) bar))
        (((|) foo bar))
        (((|) foo) bar)
        (((|)) foo bar)
        ((|) () foo bar)
        ((|) () foo) bar
        ((|) ()) foo bar
        ((|)) () foo bar
        (|) () () foo bar
<

INSERT MODE MAPPINGS (insert, optional) ~

(                                          *<Plug>(sexp_insert_opening_round)*
[                                         *<Plug>(sexp_insert_opening_square)*
{                                          *<Plug>(sexp_insert_opening_curly)*
        Insert a pair of '(' and ')', '[' and ']', or '{' and '}', inserting
        spaces as necessary to separate the new list from adjacent
        non-compound elements.

        If the cursor is in a string, regular expression, comment, or
        character atom, insert an unpaired bracket.

        To force insertion of the bracket, precede it with |i_Ctrl-V|.

)                                          *<Plug>(sexp_insert_closing_round)*
]                                         *<Plug>(sexp_insert_closing_square)*
}                                          *<Plug>(sexp_insert_closing_curly)*
        Insert a closing ')', ']', or '}' if the corresponding opening bracket
        is unpaired. If it is paired, jump to the next paired instance of
        the closing bracket. If the cursor is on the paired closing bracket,
        advance one character to the right.

        If the cursor is in a string, regular expression, comment, or
        character atom, insert an unpaired bracket.

        To force insertion of the bracket, precede it with |i_Ctrl-V|.

"                                           *<Plug>(sexp_insert_double_quote)*
        Insert a pair of double quotes, inserting spaces as necessary to
        separate the new string from adjacent non-compound elements.

        If the cursor is in a string or regular expression, insert an unpaired
        quote. If the cursor is on a double quote, advance one character to
        the right, unless the previous character is a backslash, in which case
        the quote is inserted regardless.

        If the cursor is in a comment or character atom, insert an unpaired
        quote.

        To force insertion of the quote, precede it with |i_Ctrl-V|.

<BS>                                           *<Plug>(sexp_insert_backspace)*
        Delete adjacent double quotes from within a string, unless the leading
        quote is preceded by another quote or a backslash.

        Delete adjacent paired brackets, unless the cursor is in a string,
        regular expression, comment, or character atom.

        Normal backspace otherwise.

AUTO INDENT                                                 *sexp-auto-indent*

A number of sexp commands modify forms in a way that changes list structure,
sometimes dramatically. Rather than force the user to perform a re-indent
manually in such cases, sexp's default configuration performs an automatic
re-indent on the affected region. Moreover, depending on the setting of
|g:sexp_indent_does_clean| and |g:sexp_indent_aligns_comments|, the
auto-indent may also clean up excess whitespace and/or align trailing
comments.
See |sexp-clean-indent| and |sexp-comment-alignment| for details.

In most cases, this targeted re-indent has negligible performance impact;
however, you can disable it if you wish, either globally or for specific
commands. To disable auto-indent for **all** commands, simply set
|g:sexp_auto_indent| to 0. To disable auto-indent for specific commands only,
leave |g:sexp_auto_indent| at its default value (-1) and clear the applicable
per-command flags with names given by |g:sexp_{command}_does_indent|. The
following {command} names are currently supported:
        clone
        raise
        splice
        capture_emit

==============================================================================
III. OPTIONS                                                    *sexp-options*

                                                            *g:sexp_filetypes*
A string representing an |autocmd-pattern| for the |FileType|s in which you
wish to activate vim-sexp mappings.
>
        " Default
        let g:sexp_filetypes = 'clojure,scheme,lisp,timl,fennel'
<
                                          *g:sexp_enable_insert_mode_mappings*
Toggle insert mode mappings in |g:sexp_filetypes|.
>
        " Default
        let g:sexp_enable_insert_mode_mappings = 1
<
                                                    *g:sexp_insert_after_wrap*
Enter insert mode (and append a space after the opening bracket when inserting
at head) after using a wrap command like |<Plug>(sexp_round_head_wrap_list)|.
>
        " Default
        let g:sexp_insert_after_wrap = 1
<
                                                    *g:sexp_indent_does_clean*
Remove "extra" whitespace before performing an indent. Affects behavior of
indent and clone commands. For details, see sections |clean-indent| and
|clone-does-indent|.
>
        " Default
        let g:sexp_indent_does_clean = 0
<

Auto-indent options  ~

                                                          *g:sexp_auto_indent*
The default value of -1 has no effect, but setting this variable to 0 or 1
overrides **all** of the command-specific |g:sexp_{command}_does_indent| flags.
For details, see section |sexp-auto-indent|.
>
        " Default
        let g:sexp_auto_indent = -1
<
                                                    *g:sexp_clone_does_indent*
Automatically re-indent the target(s) of a multi-line clone operation.
See also |sexp-auto-indent|.
>
        " Default
        let g:sexp_clone_does_indent = 1
<
                                             *g:sexp_capture_emit_does_indent*
Automatically re-indent the forms involved in a multi-line capture/emit
operation.
See also |sexp-auto-indent|.
>
        " Default
        let g:sexp_capture_emit_does_indent = 1
<
                                                    *g:sexp_splice_does_indent*
Automatically re-indent the target(s) of a multi-line sexp_splice operation.
See also |sexp-auto-indent|.
>
        " Default
        let g:sexp_splice_does_indent = 1
<
                                                    *g:sexp_raise_does_indent*
Automatically re-indent the target(s) of a multi-line sexp_raise operation.
See also |sexp-auto-indent|.
>
        " Default
        let g:sexp_raise_does_indent = 1
<
Set this flag to force cursor to remain with its list, even when the element
under it is emitted. Default behavior matches Paredit.
See also |sexp-emit-cursor-logic|.
>
        " Default
        let g:sexp_emitting_bracket_is_sticky = 0
<
Set this flag to force cursor to stick to a capturing bracket positioned
beneath it at capture command invocation. Default behavior matches Paredit.
See also |sexp-capture-cursor-logic|.
>
        " Default
        let g:sexp_capturing_bracket_is_sticky = 0
<
                                                 *g:sexp_prefer_legacy_syntax*
Prefer using Vim's legacy syntax engine to determine element boundaries, even
when the Treesitter library is available. (Applies only to Neovim users.)
*Caveat*: Using Treesitter should be significantly faster than legacy syntax;
thus, please report any issues you believe are fixed by setting this option.
>
        " Default
        let g:sexp_prefer_legacy_syntax = 0
<
                                             *g:sexp_cleanup_keep_empty_lines*
When there are multiple consecutive empty lines, preserve up to this many.
>
        " Default
        let g:sexp_cleanup_keep_empty_lines = 1
<
                                          *g:sexp_cleanup_collapse_whitespace*
Collapse all adjacent whitespace between elements to a single space, provided
it's not within a comment or string or immediately preceding a comment.
>
        " Default
        let g:sexp_cleanup_collapse_whitespace = 0
<
                                                *g:sexp_cleanup_join_affinity*
Determines scenarios in which outer selection attempts to ensure that a
subsequent delete would pull element following selection onto end of line
containing element preceding selection.
  0  never append
  1  append to head of list only
  2  append anywhere but top-level
  3  append anywhere (including top-level)
Default setting permits join only when the first selected element is the
second element of a list: e.g., with the default setting...
>
        (fn foo
            bar baz
            blammo)
<
...dae on "foo" would pull "bar baz" onto the start
line, but dae on "baz" would *not* pull "blammo" onto the same line as "bar".

Related options: ~
        |g:sexp_cleanup_join_textwidth|, |g:sexp_cleanup_join_multiline|
>
        " Default
        let g:sexp_cleanup_join_affinity = 1
<
                                               *g:sexp_cleanup_join_textwidth*
Line length constraint applied to outer selection cleanup logic, which avoids
making selections whose deletion would result in a line longer than the
specified length. The value can take either of the following forms:
Integer:  ~
  -1  use &tw
   0  ignore line length
  >0  max line width to create with join
Float:  ~
  >0  Fraction of original line length used to validate join.
      For instance, a value of 1.5 would prohibit joins that increased line
      length by more than 50%.

Note: This option has no effect if |g:sexp_cleanup_join_affinity| is 0.

Related options ~
        |g:sexp_cleanup_join_affinity|, |g:sexp_cleanup_join_multiline|
>
        " Default
        let g:sexp_cleanup_join_textwidth = -1
<
                                               *g:sexp_cleanup_join_multiline*
Whether to make outer element selections whose deletion would join a
multi-line element to the line containing the element preceding the selection.
  0  Consider only single-line elements as join candidates.
  1  Join logic makes no distinction between single and multi-line elements.
Related options: ~
        |g:sexp_cleanup_join_affinity|, |g:sexp_cleanup_join_textwidth|
>
        " Default
        let g:sexp_cleanup_join_multiline = 0
<
                                                *g:sexp_cleanup_join_comments*
When all other join conditions are met, allow an outer element selection whose
deletion would result in a comment being appended to a non-empty line.
>
        " Default
        let g:sexp_cleanup_join_comments = 1
<
                                               *g:sexp_cleanup_join_backwards*
When all other join conditions are met, allow an outer element selection whose
deletion would remove one or more preceding newlines, thereby moving the
cursor to an earlier line.
>
        " Default
        let g:sexp_cleanup_join_backwards = 1
<
                                               *g:sexp_indent_aligns_comments*
Align end-of-line comments automatically after performing an indent.
>
        " Default
        let g:sexp_indent_aligns_comments = 0
<

                                                    *g:sexp_aligncom_maxshift*
Maximum number of screen columns an end-of-line comment is allowed to shift
rightward to align with other columns in an end-of-line comment block.
  -1           Have plugin calculate default dynamically (currently, 75% of
               effective 'textwidth'. (See |g:sexp_aligncom_textwidth|.)
  >0           Desired maximum shift in screen columns
>
        " Default: 75% of effective 'textwidth'
        let g:sexp_aligncom_maxshift = -1
<

                                                      *g:sexp_aligncom_maxgap*
The maximum line gap permitted between successive end-of-line comments in the
same group: i.e., comments separated by more than this distance will not be
considered for inclusion in the same comment block.
*Rationale*: When successive comments are separated by significant vertical
distance, the benefit of combining them into a single group decreases, and may
even by outweighed by the performance penalty incurred by long groups.
>
        " Default
        let g:sexp_aligncom_maxgap = 7
<
                                            *g:sexp_aligncom_break_at_comment*
Full line comments always separate end-of-line comment groups. If this option
is not set, line comments have no impact on alignment.
>
        " Default
        let g:sexp_aligncom_break_at_comment = 0
<
                                         *g:sexp_aligncom_ignore_non_comments*
Lines without comments have no effect on trailing comment alignment.
*Examples*:
>
        let g:sexp_aligncom_ignore_non_comments = 1
<
        (foo)     ; comment
        (bar)     ; comment
        (no-eol-comment)
        (baz)     ; comment
        (blammo)  ; comment
>
        let g:sexp_aligncom_ignore_non_comments = 0
<
        (foo)             ; comment
        (bar)             ; comment
        (no-eol-comment)
        (baz)             ; comment
        (blammo)          ; comment
>
        " Default
        let g:sexp_aligncom_ignore_non_comments = 0
<
                                                   *g:sexp_aligncom_textwidth*
Trailing comment alignment optimization deprioritizes comment groupings that
produce lines longer than this, with a penalty proportional to the overrun.
  -1  use &tw
   0  ignore line length (same as |g:sexp_aligncom_textwidth_weight| == 0)
  >0  max desired line length
>
        " Default
        let g:sexp_aligncom_textwidth = -1
<
                                                 *g:sexp_aligncom_runt_thresh*
Trailing comment groups containing fewer comments than this are considered
"runt" groups, and deprioritized with a cost proportional to the square of the
shortfall.
>
        " Default
        let g:sexp_aligncom_runt_thresh = 5
<
                                              *g:sexp_aligncom_min_separation*
Minimum number of spaces needed between end of code and start of trailing
comment. Note that this is only a minimum; maximum depends on specific
alignment and |g:sexp_aligncom_maxshift|.
>
        " Default
        let g:sexp_aligncom_min_separation = 2
<
                                                    *g:sexp_aligncom_colstops*
Analogous to a 'tabstop' for trailing comments. If set to a nonzero value,
trailing comments will be aligned to screen columns which are multiples of
this value. Setting this option to a small value > 1 will prevent adjacent
blocks of trailing comments whose alignment is "off-by-one". In the author's
opinion, such blocks can look unsightly, though this is obviously entirely
subjective. Another advantage of setting this option to a small value > 1 is
that it introduces a bit of "wiggle room" into the alignment, preventing small
shifts to trailing comment placement when a block of code is re-indented after
a minor code change.
>
        " Default
        let g:sexp_aligncom_colstops = 2
<
                                             *g:sexp_aligncom_greedy_lookback*
The number of lines from preceding long group to include in localized
optimization when performing "greedy with lookback" (level 1) optimization.
See |layout-optimization-levels| for details.
>
        " Default
        let g:sexp_aligncom_greedy_lookback = 4
<
                                                    *g:sexp_aligncom_optlevel*
Select desired trailing comment optimization level:
  0  Greedy
  1  Greedy with lookback
  2  Full dynamic-programming optimization
For details, see |layout-optimization-levels|.
>
        " Default
        let g:sexp_aligncom_optlevel = 2
<
                                              *g:sexp_aligncom_optlvl1_thresh*
Select optimization level 1 ("Greedy with Lookback") if number of end-of-line
comments in range to be aligned is greater than or equal to this threshold.
Set to 1 to enable optimization level 1 unconditionally.
>
        " Default
        let g:sexp_aligncom_optlvl1_thresh = 0
<
                                            *g:sexp_aligncom_numgroups_weight*
The relative importance (0-10) of minimizing the total number of groups when
partitioning lines into alignment groups. Applies only to full (level 2)
optimization.
>
        " Default
        let g:sexp_aligncom_numgroups_weight = 5
<
                                                *g:sexp_aligncom_shift_weight*
The relative importance (0-10) of minimizing the distance by which trailing
comments are separated from the code they describe. Applies only to full
(level 2) optimization.
>
        " Default
        let g:sexp_aligncom_shift_weight = 5
<
                                             *g:sexp_aligncom_runtness_weight*
The relative importance (0-10) of preventing the formation of "runt" comment
groups: i.e., groups with fewer than |g:sexp_aligncom_runt_thresh| trailing
comments. Applies only to full (level 2) optimization.
>
        " Default
        let g:sexp_aligncom_runtness_weight = 5
<
                                            *g:sexp_aligncom_textwidth_weight*
The relative importance (0-10) of reducing the amount of trailing comment
overrun, as determined by |g:sexp_aligncom_textwidth|. Applies only to full
(level 2) optimization.
>
        " Default
        let g:sexp_aligncom_textwidth_weight = 5
<
                                              *g:sexp_aligncom_density_weight*
The relative importance (0-10) of avoiding trailing comment groups with
"bookends": i.e., a comment at each end, but none between. Applies only to
full (level 2) optimization.
>
        " Default
        let g:sexp_aligncom_density_weight = 5
<
Expert options ~

                                                     *g:sexp_inhibit_failsafe*
In the absence of bugs, this plugin should never modify non-whitespace text
(though it may occasionally **relocate** brackets). In the real world,
however, bugs happen; thus, the function responsible for modifying text
contains redundant logic to ensure that if a bug results in a request to
delete non-whitespace, the request will be refused with a warning. The regex
search used by this logic is fairly inexpensive and unlikely to be a
performance concern; however, for users who prioritize performance and trust
the developer, their version control system, Vim's undo engine, or some
combination of the above, an option is provided to inhibit this "failsafe"
mechanism, potentially eking out a bit more performance, especially for
operations that perform signficant whitespace cleanup.
>
        " Default
        let g:sexp_inhibit_failsafe = 0
<

Customizing keymaps ~
                                                             *g:sexp_mappings*
Vim-sexp provides default mappings for most commands, but you can override
these defaults by adding entries to global Dictionary `g:sexp_mappings`, whose
keys are the command names with the surrounding `<Plug>(...)` removed,
and whose values are the key sequences you wish to bind to.

Any global version of this dictionary you provide will be merged into the
default dictionary shown below, so the global version needn't contain entries
for commands you don't wish to override.
Note: To unbind a command, simply set its <lhs> to an empty string.
>
        " vim-sexp internal mappings
        let s:sexp_mappings = {
            \ 'sexp_outer_list':                'af',
            \ 'sexp_inner_list':                'if',
            \ 'sexp_outer_top_list':            'aF',
            \ 'sexp_inner_top_list':            'iF',
            \ 'sexp_outer_string':              'as',
            \ 'sexp_inner_string':              'is',
            \ 'sexp_outer_element':             'ae',
            \ 'sexp_inner_element':             'ie',
            \ 'sexp_outer_child_tail':          'aC',
            \ 'sexp_outer_child_head':          'ac',
            \ 'sexp_inner_child_tail':          'iC',
            \ 'sexp_inner_child_head':          'ic',
            \ 'sexp_move_to_prev_bracket':      '(',
            \ 'sexp_move_to_next_bracket':      ')',
            \ 'sexp_move_to_prev_element_head': '<M-b>',
            \ 'sexp_move_to_next_element_head': '<M-w>',
            \ 'sexp_move_to_prev_element_tail': 'g<M-e>',
            \ 'sexp_move_to_next_element_tail': '<M-e>',
            \ 'sexp_flow_to_prev_close':        '<M-[>',
            \ 'sexp_flow_to_next_open':         '<M-]>',
            \ 'sexp_flow_to_prev_open':         '<M-{>',
            \ 'sexp_flow_to_next_close':        '<M-}>',
            \ 'sexp_flow_to_prev_leaf_head':    '<M-S-b>',
            \ 'sexp_flow_to_next_leaf_head':    '<M-S-w>',
            \ 'sexp_flow_to_prev_leaf_tail':    '<M-S-g>',
            \ 'sexp_flow_to_next_leaf_tail':    '<M-S-e>',
            \ 'sexp_move_to_prev_top_element':  '[[',
            \ 'sexp_move_to_next_top_element':  ']]',
            \ 'sexp_select_prev_element':       '[e',
            \ 'sexp_select_next_element':       ']e',
            \ 'sexp_indent':                    '==',
            \ 'sexp_indent_top':                '=-',
            \ 'sexp_indent_and_clean':          '<M-=>',
            \ 'sexp_indent_and_clean_top':      '<M-->',
            \ 'sexp_align_comments':            '<LocalLeader>a',
            \ 'sexp_align_comments_top':        '<LocalLeader>A',
            \ 'sexp_round_head_wrap_list':      '<LocalLeader>i',
            \ 'sexp_round_tail_wrap_list':      '<LocalLeader>I',
            \ 'sexp_square_head_wrap_list':     '<LocalLeader>[',
            \ 'sexp_square_tail_wrap_list':     '<LocalLeader>]',
            \ 'sexp_curly_head_wrap_list':      '<LocalLeader>{',
            \ 'sexp_curly_tail_wrap_list':      '<LocalLeader>}',
            \ 'sexp_round_head_wrap_element':   '<LocalLeader>w',
            \ 'sexp_round_tail_wrap_element':   '<LocalLeader>W',
            \ 'sexp_square_head_wrap_element':  '<LocalLeader>e[',
            \ 'sexp_square_tail_wrap_element':  '<LocalLeader>e]',
            \ 'sexp_curly_head_wrap_element':   '<LocalLeader>e{',
            \ 'sexp_curly_tail_wrap_element':   '<LocalLeader>e}',
            \ 'sexp_insert_at_list_head':       '<LocalLeader>h',
            \ 'sexp_insert_at_list_tail':       '<LocalLeader>l',
            \ 'sexp_splice_list':               '<LocalLeader>@',
            \ 'sexp_convolute':                 '<LocalLeader>?',
            \ 'sexp_clone_list':                '<LocalLeader>c',
            \ 'sexp_clone_list_sl':             '',
            \ 'sexp_clone_list_ml':             '',
            \ 'sexp_clone_element':             '<LocalLeader>C',
            \ 'sexp_clone_element_sl':          '',
            \ 'sexp_clone_element_ml':          '',
            \ 'sexp_raise_list':                '<LocalLeader>o',
            \ 'sexp_raise_element':             '<LocalLeader>O',
            \ 'sexp_swap_list_backward':        '<M-k>',
            \ 'sexp_swap_list_forward':         '<M-j>',
            \ 'sexp_swap_element_backward':     '<M-h>',
            \ 'sexp_swap_element_forward':      '<M-l>',
            \ 'sexp_emit_head_element':         '<M-S-j>',
            \ 'sexp_emit_tail_element':         '<M-S-k>',
            \ 'sexp_capture_prev_element':      '<M-S-h>',
            \ 'sexp_capture_next_element':      '<M-S-l>',
            \ }
<
Override Example: ~
To avoid shadowing Vim's builtin "sentence" mappings, you could define the
following `g:sexp_mappings`:
>
        let g:sexp_mappings = {
            \ 'sexp_outer_string':              'aS',
            \ 'sexp_inner_string':              'iS',
            \ 'sexp_move_to_prev_bracket':      'g(',
            \ 'sexp_move_to_next_bracket':      'g)',
        \ }
<

                                                             *g:sexp_maxlines*
Searching for paired brackets is accomplished with the |searchpairpos()|
function, and it is invoked quite often in this plugin.
Note: Calls to `searchpairpos()` are more rare in Neovim with Treesitter
support, and will probably be eliminated altogether in a future version.

If g:sexp_maxlines is 0 or -1, |searchpairpos()| scans the entire buffer for
its match, which can be slow if the nearest bracket is far from the cursor.
If g:sexp_maxlines is positive, the scan is limited to this number of lines,
trading accuracy for performance.

If searching for a top-level compound form via |<Plug>(sexp_outer_top_list)|
or |<Plug>(sexp_move_to_prev_top_element)| with g:sexp_maxlines equal to 0,
|searchpairpos()| will be run recursively until the whole buffer is scanned
for possible unpaired brackets. In moderately large buffers, this is an
extremely slow operation. Setting g:sexp_maxlines to about 100 removes this
speed penalty, but the accuracy often suffers noticeably.

If g:sexp_maxlines is set to -1, top-level bracket searches stop when a
bracket is found in the first column. For most Lisp buffers, this is both
accurate and relatively quick, so it is the default setting.
>
        " Default
        let g:sexp_maxlines = -1
<
==============================================================================
IV. EXPLICIT MAPPINGS                                 *sexp-explicit-mappings*

If you find managing your mappings via |g:sexp_mappings| awkward, you may wish
to opt for a more explicit mapping configuration instead.

First, disable the provided mapping system by setting |g:sexp_filetypes| to an
empty string:
>
        " Disable mapping hooks
        let g:sexp_filetypes = ''
<
Next, write a function that will create your desired |:map-local| bindings.
The following example includes every default mapping in vim-sexp. You can
copy, paste, and edit this example to taste.
>
        function! s:vim_sexp_mappings()
            xmap <silent><buffer> af              <Plug>(sexp_outer_list)
            omap <silent><buffer> af              <Plug>(sexp_outer_list)
            xmap <silent><buffer> if              <Plug>(sexp_inner_list)
            omap <silent><buffer> if              <Plug>(sexp_inner_list)
            xmap <silent><buffer> aF              <Plug>(sexp_outer_top_list)
            omap <silent><buffer> aF              <Plug>(sexp_outer_top_list)
            xmap <silent><buffer> iF              <Plug>(sexp_inner_top_list)
            omap <silent><buffer> iF              <Plug>(sexp_inner_top_list)
            xmap <silent><buffer> as              <Plug>(sexp_outer_string)
            omap <silent><buffer> as              <Plug>(sexp_outer_string)
            xmap <silent><buffer> is              <Plug>(sexp_inner_string)
            omap <silent><buffer> is              <Plug>(sexp_inner_string)
            xmap <silent><buffer> ae              <Plug>(sexp_outer_element)
            omap <silent><buffer> ae              <Plug>(sexp_outer_element)
            xmap <silent><buffer> ie              <Plug>(sexp_inner_element)
            omap <silent><buffer> ie              <Plug>(sexp_inner_element)
            xmap <silent><buffer> ac              <Plug>(sexp_outer_child_head)
            omap <silent><buffer> ac              <Plug>(sexp_outer_child_head)
            xmap <silent><buffer> ic              <Plug>(sexp_inner_child_head)
            omap <silent><buffer> ic              <Plug>(sexp_inner_child_head)
            xmap <silent><buffer> aC              <Plug>(sexp_outer_child_tail)
            omap <silent><buffer> aC              <Plug>(sexp_outer_child_tail)
            xmap <silent><buffer> iC              <Plug>(sexp_inner_child_tail)
            omap <silent><buffer> iC              <Plug>(sexp_inner_child_tail)
            nmap <silent><buffer> (               <Plug>(sexp_move_to_prev_bracket)
            xmap <silent><buffer> (               <Plug>(sexp_move_to_prev_bracket)
            omap <silent><buffer> (               <Plug>(sexp_move_to_prev_bracket)
            nmap <silent><buffer> )               <Plug>(sexp_move_to_next_bracket)
            xmap <silent><buffer> )               <Plug>(sexp_move_to_next_bracket)
            omap <silent><buffer> )               <Plug>(sexp_move_to_next_bracket)
            nmap <silent><buffer> <M-b>           <Plug>(sexp_move_to_prev_element_head)
            xmap <silent><buffer> <M-b>           <Plug>(sexp_move_to_prev_element_head)
            omap <silent><buffer> <M-b>           <Plug>(sexp_move_to_prev_element_head)
            nmap <silent><buffer> <M-w>           <Plug>(sexp_move_to_next_element_head)
            xmap <silent><buffer> <M-w>           <Plug>(sexp_move_to_next_element_head)
            omap <silent><buffer> <M-w>           <Plug>(sexp_move_to_next_element_head)
            nmap <silent><buffer> g<M-e>          <Plug>(sexp_move_to_prev_element_tail)
            xmap <silent><buffer> g<M-e>          <Plug>(sexp_move_to_prev_element_tail)
            omap <silent><buffer> g<M-e>          <Plug>(sexp_move_to_prev_element_tail)
            nmap <silent><buffer> <M-e>           <Plug>(sexp_move_to_next_element_tail)
            xmap <silent><buffer> <M-e>           <Plug>(sexp_move_to_next_element_tail)
            omap <silent><buffer> <M-e>           <Plug>(sexp_move_to_next_element_tail)
            nmap <silent><buffer> [[              <Plug>(sexp_move_to_prev_top_element)
            xmap <silent><buffer> [[              <Plug>(sexp_move_to_prev_top_element)
            omap <silent><buffer> [[              <Plug>(sexp_move_to_prev_top_element)
            nmap <silent><buffer> ]]              <Plug>(sexp_move_to_next_top_element)
            xmap <silent><buffer> ]]              <Plug>(sexp_move_to_next_top_element)
            omap <silent><buffer> ]]              <Plug>(sexp_move_to_next_top_element)
            nmap <silent><buffer> [e              <Plug>(sexp_select_prev_element)
            xmap <silent><buffer> [e              <Plug>(sexp_select_prev_element)
            omap <silent><buffer> [e              <Plug>(sexp_select_prev_element)
            nmap <silent><buffer> ]e              <Plug>(sexp_select_next_element)
            xmap <silent><buffer> ]e              <Plug>(sexp_select_next_element)
            omap <silent><buffer> ]e              <Plug>(sexp_select_next_element)
            nmap <silent><buffer> <M-]>           <Plug>(sexp_flow_to_next_open)
            xmap <silent><buffer> <M-]>           <Plug>(sexp_flow_to_next_open)
            nmap <silent><buffer> <M-[>           <Plug>(sexp_flow_to_prev_close)
            xmap <silent><buffer> <M-[>           <Plug>(sexp_flow_to_prev_close)
            nmap <silent><buffer> <M-{>           <Plug>(sexp_flow_to_prev_open)
            xmap <silent><buffer> <M-{>           <Plug>(sexp_flow_to_prev_open)
            nmap <silent><buffer> <M-}>           <Plug>(sexp_flow_to_next_close)
            xmap <silent><buffer> <M-}>           <Plug>(sexp_flow_to_next_close)
            nmap <silent><buffer> <M-S-b>         <Plug>(sexp_flow_to_prev_leaf_head)
            xmap <silent><buffer> <M-S-b>         <Plug>(sexp_flow_to_prev_leaf_head)
            nmap <silent><buffer> <M-S-w>         <Plug>(sexp_flow_to_next_leaf_head)
            xmap <silent><buffer> <M-S-w>         <Plug>(sexp_flow_to_next_leaf_head)
            nmap <silent><buffer> <M-S-g>         <Plug>(sexp_flow_to_prev_leaf_tail)
            xmap <silent><buffer> <M-S-g>         <Plug>(sexp_flow_to_prev_leaf_tail)
            nmap <silent><buffer> <M-S-e>         <Plug>(sexp_flow_to_next_leaf_tail)
            xmap <silent><buffer> <M-S-e>         <Plug>(sexp_flow_to_next_leaf_tail)
            nmap <silent><buffer> <LocalLeader>c  <Plug>(sexp_clone_list)
            xmap <silent><buffer> <LocalLeader>c  <Plug>(sexp_clone_list)
            nmap <silent><buffer> <LocalLeader><LocalLeader>c  <Plug>(sexp_clone_list_sl)
            xmap <silent><buffer> <LocalLeader><LocalLeader>c  <Plug>(sexp_clone_list_sl)
            nmap <silent><buffer> <LocalLeader>C  <Plug>(sexp_clone_element)
            xmap <silent><buffer> <LocalLeader>C  <Plug>(sexp_clone_element)
            nmap <silent><buffer> <LocalLeader><LocalLeader>C  <Plug>(sexp_clone_element_sl)
            xmap <silent><buffer> <LocalLeader><LocalLeader>C  <Plug>(sexp_clone_element_sl)
            " Feel free to add sexp_clone_{list,element}_ml variants as well.
            nmap <silent><buffer> ==              <Plug>(sexp_indent)
            xmap <silent><buffer> =               <Plug>(sexp_indent)
            nmap <silent><buffer> =-              <Plug>(sexp_indent_top)
            nmap <silent><buffer> <M-=>           <Plug>(sexp_indent_and_clean)
            xmap <silent><buffer> <M-=>           <Plug>(sexp_indent_and_clean)
            nmap <silent><buffer> <M-->           <Plug>(sexp_indent_and_clean_top)
            nmap <silent><buffer> <LocalLeader>a  <Plug>(sexp_align_comments)
            xmap <silent><buffer> <LocalLeader>a  <Plug>(sexp_align_comments)
            nmap <silent><buffer> <LocalLeader>A  <Plug>(sexp_align_comments_top)
            nmap <silent><buffer> <LocalLeader>i  <Plug>(sexp_round_head_wrap_list)
            xmap <silent><buffer> <LocalLeader>i  <Plug>(sexp_round_head_wrap_list)
            nmap <silent><buffer> <LocalLeader>I  <Plug>(sexp_round_tail_wrap_list)
            xmap <silent><buffer> <LocalLeader>I  <Plug>(sexp_round_tail_wrap_list)
            nmap <silent><buffer> <LocalLeader>[  <Plug>(sexp_square_head_wrap_list)
            xmap <silent><buffer> <LocalLeader>[  <Plug>(sexp_square_head_wrap_list)
            nmap <silent><buffer> <LocalLeader>]  <Plug>(sexp_square_tail_wrap_list)
            xmap <silent><buffer> <LocalLeader>]  <Plug>(sexp_square_tail_wrap_list)
            nmap <silent><buffer> <LocalLeader>{  <Plug>(sexp_curly_head_wrap_list)
            xmap <silent><buffer> <LocalLeader>{  <Plug>(sexp_curly_head_wrap_list)
            nmap <silent><buffer> <LocalLeader>}  <Plug>(sexp_curly_tail_wrap_list)
            xmap <silent><buffer> <LocalLeader>}  <Plug>(sexp_curly_tail_wrap_list)
            nmap <silent><buffer> <LocalLeader>w  <Plug>(sexp_round_head_wrap_element)
            xmap <silent><buffer> <LocalLeader>w  <Plug>(sexp_round_head_wrap_element)
            nmap <silent><buffer> <LocalLeader>W  <Plug>(sexp_round_tail_wrap_element)
            xmap <silent><buffer> <LocalLeader>W  <Plug>(sexp_round_tail_wrap_element)
            nmap <silent><buffer> <LocalLeader>e[ <Plug>(sexp_square_head_wrap_element)
            xmap <silent><buffer> <LocalLeader>e[ <Plug>(sexp_square_head_wrap_element)
            nmap <silent><buffer> <LocalLeader>e] <Plug>(sexp_square_tail_wrap_element)
            xmap <silent><buffer> <LocalLeader>e] <Plug>(sexp_square_tail_wrap_element)
            nmap <silent><buffer> <LocalLeader>e{ <Plug>(sexp_curly_head_wrap_element)
            xmap <silent><buffer> <LocalLeader>e{ <Plug>(sexp_curly_head_wrap_element)
            nmap <silent><buffer> <LocalLeader>e} <Plug>(sexp_curly_tail_wrap_element)
            xmap <silent><buffer> <LocalLeader>e} <Plug>(sexp_curly_tail_wrap_element)
            nmap <silent><buffer> <LocalLeader>h  <Plug>(sexp_insert_at_list_head)
            nmap <silent><buffer> <LocalLeader>l  <Plug>(sexp_insert_at_list_tail)
            nmap <silent><buffer> <LocalLeader>@  <Plug>(sexp_splice_list)
            nmap <silent><buffer> <LocalLeader>?  <Plug>(sexp_convolute)
            nmap <silent><buffer> <LocalLeader>o  <Plug>(sexp_raise_list)
            xmap <silent><buffer> <LocalLeader>o  <Plug>(sexp_raise_list)
            nmap <silent><buffer> <LocalLeader>O  <Plug>(sexp_raise_element)
            xmap <silent><buffer> <LocalLeader>O  <Plug>(sexp_raise_element)
            nmap <silent><buffer> <M-k>           <Plug>(sexp_swap_list_backward)
            xmap <silent><buffer> <M-k>           <Plug>(sexp_swap_list_backward)
            nmap <silent><buffer> <M-j>           <Plug>(sexp_swap_list_forward)
            xmap <silent><buffer> <M-j>           <Plug>(sexp_swap_list_forward)
            nmap <silent><buffer> <M-h>           <Plug>(sexp_swap_element_backward)
            xmap <silent><buffer> <M-h>           <Plug>(sexp_swap_element_backward)
            nmap <silent><buffer> <M-l>           <Plug>(sexp_swap_element_forward)
            xmap <silent><buffer> <M-l>           <Plug>(sexp_swap_element_forward)
            nmap <silent><buffer> <M-S-j>         <Plug>(sexp_emit_head_element)
            xmap <silent><buffer> <M-S-j>         <Plug>(sexp_emit_head_element)
            nmap <silent><buffer> <M-S-k>         <Plug>(sexp_emit_tail_element)
            xmap <silent><buffer> <M-S-k>         <Plug>(sexp_emit_tail_element)
            nmap <silent><buffer> <M-S-h>         <Plug>(sexp_capture_prev_element)
            xmap <silent><buffer> <M-S-h>         <Plug>(sexp_capture_prev_element)
            nmap <silent><buffer> <M-S-l>         <Plug>(sexp_capture_next_element)
            xmap <silent><buffer> <M-S-l>         <Plug>(sexp_capture_next_element)
            imap <silent><buffer> <BS>            <Plug>(sexp_insert_backspace)
            imap <silent><buffer> "               <Plug>(sexp_insert_double_quote)
            imap <silent><buffer> (               <Plug>(sexp_insert_opening_round)
            imap <silent><buffer> )               <Plug>(sexp_insert_closing_round)
            imap <silent><buffer> [               <Plug>(sexp_insert_opening_square)
            imap <silent><buffer> ]               <Plug>(sexp_insert_closing_square)
            imap <silent><buffer> {               <Plug>(sexp_insert_opening_curly)
            imap <silent><buffer> }               <Plug>(sexp_insert_closing_curly)
        endfunction
<
Finally, install a |FileType| |autocmd| that will execute the function above
in the filetypes of your choosing.
>
        augroup VIM_SEXP_MAPPING
            autocmd!
            autocmd FileType clojure,scheme,lisp,timl,fennel call s:vim_sexp_mappings()
        augroup END
<
==============================================================================
V.  LAZY INSTALLATION EXAMPLE

                                                           *sexp-lazy-install*
To install vim-sexp with the popular Lazy plugin manager (Neovim-only), create
a Lazy plugin spec containing your vim-sexp customized keymap and option
settings under stdpath('config').

Note: A future version of vim-sexp will likely support a more idiomatic plugin
spec: i.e., one which uses a nested 'opts' table and does not require explicit
override of 'init'.

Example ~
-- File: ~/.config/nvim/lua/plugins/vim-sexp.lua

return {
  'guns/vim-sexp',
  lazy = false,
  init = function()
    -- General plugin option settings
    vim.g.sexp_indent_does_clean = 1
    vim.g.sexp_clone_does_indent = 1
    vim.g.sexp_indent_aligns_comments = 1
    -- Custom keymaps
    vim.g.sexp_mappings = {
      -- Note: Commands not overridden here will use default keymaps.
      -- Note: Setting to empty string disables a command.
      sexp_indent_and_clean = '<M-=>',
      sexp_indent_and_clean_top = '<M-->',
      sexp_align_comments = '<M-a>',
      sexp_align_comments_top = '<M-\\>',
      sexp_insert_at_list_head = '<M-I>',
      sexp_insert_at_list_tail = '<M-A>',
      sexp_splice_list = '<M-@>',
      sexp_convolute = '<M-?>',
      sexp_clone_list = '<LocalLeader>C',
      sexp_clone_list_sl = '<LocalLeader><LocalLeader>C',
      sexp_clone_list_ml = '<A-C>',
      sexp_clone_element = '<LocalLeader>c',
      sexp_clone_element_sl = '<LocalLeader><LocalLeader>c',
      sexp_clone_element_ml = '<A-c>',
      sexp_raise_list = '<M-O>',
      sexp_raise_element = '<M-o>',
      sexp_swap_list_backward = '<M-H>',
      sexp_swap_list_forward = '<M-L>',
      sexp_swap_element_backward = '<M-h>',
      sexp_swap_element_forward = '<M-l>',
      sexp_emit_head_element = '<M-P>',
      sexp_emit_tail_element = '<M-p>',
      sexp_capture_prev_element = '<M-T>',
      sexp_capture_next_element = '<M-t>',
    }
  end,
}

==============================================================================
VI. CHANGELOG                                                 *sexp-changelog*

03 March 2015
        - Add documentation on how to opt-out of g:sexp_mappings and manually
          create per-filetype buffer local mappings.
        - Remove deprecated mappings sexp_lift_list and sexp_list_element,
          which were previously renamed to sexp_raise_list and
          sexp_raise_element respectively.
        - Remove deprecated unparenthesized <Plug> mappings.
        - Remove visual mode mappings from sexp_insert_at_list_head,
          sexp_insert_at_list_tail, and sexp_splice_list.

 vim:tw=78:et:sw=8:sts=8:ts=8:ft=help:norl:
